"""
RabbitMQ Utils Migrado a Shared Libraries - VERSIÓN CORREGIDA
"""
import json
import logging
import sys
from typing import Dict, Any
from datetime import datetime

# Configurar logging
logger = logging.getLogger(__name__)

# Añadir path para shared-libraries
sys.path.insert(0, '/app')
sys.path.insert(0, '/app/shared-libraries')

try:
    from hduce_shared.rabbitmq import RabbitMQPublisher, RabbitMQConfig
    from hduce_shared.config import settings
    logger.info("✅ Shared libraries importadas desde /app")
except ImportError as e:
    logger.error(f"❌ Error importando shared libraries desde /app: {e}")
    # Intentar importar desde local para desarrollo
    try:
        sys.path.insert(0, '..')
        from shared_libraries.hduce_shared.rabbitmq import RabbitMQPublisher, RabbitMQConfig
        from shared_libraries.hduce_shared.config import settings
        logger.info("✅ Shared libraries importadas desde local")
    except ImportError as e2:
        logger.error(f"❌ Error importando shared libraries localmente: {e2}")
        raise

# Configuración de RabbitMQ desde settings - CORREGIDO
RABBITMQ_CONFIG = RabbitMQConfig(
    host=settings.rabbitmq.rabbitmq_host,        # ¡CORREGIDO!
    port=settings.rabbitmq.rabbitmq_port,        # ¡CORREGIDO!
    username=settings.rabbitmq.rabbitmq_user,    # ¡CORREGIDO!
    password=settings.rabbitmq.rabbitmq_password # ¡CORREGIDO!
)

EXCHANGE_NAME = 'appointments'
QUEUE_NAME = 'appointment_notifications'
ROUTING_KEY = 'notification.created'


class AppointmentEventPublisher:
    """Publisher de eventos de citas usando shared libraries"""
    
    _instance = None
    _publisher = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(AppointmentEventPublisher, cls).__new__(cls)
            cls._instance._initialize()
        return cls._instance
    
    def _initialize(self):
        """Inicializar el publisher"""
        try:
            self._publisher = RabbitMQPublisher(
                config=RABBITMQ_CONFIG,
                exchange_name=EXCHANGE_NAME,
                queue_name=QUEUE_NAME,
                routing_key=ROUTING_KEY,
                exchange_type='direct',
                durable=True
            )
            logger.info(f"✅ RabbitMQPublisher inicializado para exchange: {EXCHANGE_NAME}")
        except Exception as e:
            logger.error(f"❌ Error inicializando RabbitMQPublisher: {e}")
            raise
    
    def publish_appointment_created(self, appointment_data: Dict[str, Any]) -> bool:
        """
        Publicar evento de cita creada
        
        Args:
            appointment_data: Datos de la cita
            
        Returns:
            bool: True si se publicó correctamente, False en caso contrario
        """
        try:
            event_message = {
                "event_type": "APPOINTMENT_CREATED",
                "timestamp": datetime.utcnow().isoformat(),
                "data": appointment_data,
                "metadata": {
                    "service": "appointment",
                    "version": "1.0"
                }
            }
            
            # Publicar usando shared libraries
            success = self._publisher.publish(event_message)
            
            if success:
                logger.info(f"✅ Evento APPOINTMENT_CREATED publicado: Cita {appointment_data.get('appointment_id', 'N/A')}")
            else:
                logger.error(f"❌ Falló al publicar evento APPOINTMENT_CREATED")
                
            return success
            
        except Exception as e:
            logger.error(f"❌ Error en publish_appointment_created: {e}")
            return False
    
    def publish_appointment_cancelled(self, appointment_data: Dict[str, Any]) -> bool:
        """
        Publicar evento de cita cancelada
        
        Args:
            appointment_data: Datos de la cita
            
        Returns:
            bool: True si se publicó correctamente, False en caso contrario
        """
        try:
            event_message = {
                "event_type": "APPOINTMENT_CANCELLED",
                "timestamp": datetime.utcnow().isoformat(),
                "data": appointment_data,
                "metadata": {
                    "service": "appointment",
                    "version": "1.0"
                }
            }
            
            # Publicar usando shared libraries
            success = self._publisher.publish(event_message)
            
            if success:
                logger.info(f"✅ Evento APPOINTMENT_CANCELLED publicado: Cita {appointment_data.get('appointment_id', 'N/A')}")
            else:
                logger.error(f"❌ Falló al publicar evento APPOINTMENT_CANCELLED")
                
            return success
            
        except Exception as e:
            logger.error(f"❌ Error en publish_appointment_cancelled: {e}")
            return False


# Instancia singleton global
_event_publisher = AppointmentEventPublisher()


def publish_appointment_created(appointment_data: Dict[str, Any]) -> bool:
    """
    Publicar evento de cita creada - FUNCIÓN PRINCIPAL
    Mantiene compatibilidad con el código existente
    
    Args:
        appointment_data: Datos de la cita
        
    Returns:
        bool: True si se publicó correctamente, False en caso contrario
    """
    return _event_publisher.publish_appointment_created(appointment_data)


def publish_appointment_cancelled(appointment_data: Dict[str, Any]) -> bool:
    """
    Publicar evento de cita cancelada
    
    Args:
        appointment_data: Datos de la cita
        
    Returns:
        bool: True si se publicó correctamente, False en caso contrario
    """
    return _event_publisher.publish_appointment_cancelled(appointment_data)


# Alias para compatibilidad
publish_appointment_event = publish_appointment_created


# Función de prueba para verificar la conexión
def test_rabbitmq_connection():
    """Probar conexión a RabbitMQ"""
    try:
        test_data = {
            "appointment_id": 999,
            "patient_id": 1,
            "patient_email": "test@example.com",
            "patient_name": "Test User",
            "doctor_id": 1,
            "appointment_date": "2026-01-01",
            "reason": "Test connection"
        }
        
        success = publish_appointment_created(test_data)
        if success:
            logger.info("✅ Test de conexión a RabbitMQ exitoso")
            return True
        else:
            logger.error("❌ Test de conexión a RabbitMQ falló")
            return False
            
    except Exception as e:
        logger.error(f"❌ Error en test de conexión: {e}")
        return False


if __name__ == "__main__":
    # Ejecutar test si se ejecuta directamente
    logging.basicConfig(level=logging.INFO)
    test_rabbitmq_connection()
