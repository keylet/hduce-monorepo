from fastapi import APIRouter, Depends, HTTPException, status, Response
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime
import logging
import json

from database import get_db
from models import Appointment, Doctor, Specialty
from schemas import AppointmentCreate, AppointmentUpdate, AppointmentResponse, DoctorResponse
from auth_client import verify_token
from rabbitmq_utils import publish_appointment_created as publish_appointment_event

router = APIRouter(tags=["appointments"])
logger = logging.getLogger(__name__)

async def get_current_user(current_user: dict = Depends(verify_token)):
    """Obtiene el usuario actual del token verificado"""
    return current_user

# ========== ENDPOINT DOCTORS - SOLUCIÓN DEFINITIVA UTF-8 ==========
@router.get("/doctors/", response_model=List[DoctorResponse], tags=["doctors"])
async def read_doctors(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Obtener lista de doctores disponibles"""
    try:
        logger.info(f"🔍 Endpoint /doctors/ llamado por usuario: {current_user['email']}")

        # Consulta optimizada con JOIN a specialties usando objetos del modelo
        doctors = db.query(Doctor).join(
            Specialty, Doctor.specialty_id == Specialty.id, isouter=True
        ).filter(
            Doctor.is_active == True
        ).offset(skip).limit(limit).all()

        # Convertir a formato de respuesta
        result = []
        for doctor in doctors:
            doctor_data = {
                "id": doctor.id,
                "name": doctor.name,
                "email": doctor.email,
                "phone": doctor.phone,
                "is_active": doctor.is_active,
                "specialty": doctor.specialty.name if doctor.specialty else None,
                "specialty_id": doctor.specialty_id
            }
            result.append(doctor_data)

        logger.info(f"✅ Encontrados {len(result)} doctores")
        
        # SOLUCIÓN NUCLEAR: Crear respuesta manualmente con UTF-8
        import json
        from fastapi.responses import Response
        
        # Forzar ensure_ascii=False y encoding UTF-8
        json_bytes = json.dumps(result, ensure_ascii=False).encode('utf-8')
        return Response(
            content=json_bytes,
            media_type="application/json; charset=utf-8",
            status_code=200
        )

    except Exception as e:
        logger.error(f"❌ Error en /doctors/: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Error al obtener doctores: {str(e)}"
        )
@router.get("/appointments/", response_model=List[AppointmentResponse])
def read_appointments(skip: int = 0, limit: int = 100, db: Session = Depends(get_db), current_user: dict = Depends(get_current_user)):
    appointments = db.query(Appointment).offset(skip).limit(limit).all()
    return appointments

@router.get("/appointments/{appointment_id}", response_model=AppointmentResponse)
def read_appointment(appointment_id: int, db: Session = Depends(get_db), current_user: dict = Depends(get_current_user)):
    appointment = db.query(Appointment).filter(Appointment.id == appointment_id).first()
    if appointment is None:
        raise HTTPException(status_code=404, detail="Appointment not found")
    return appointment


@router.post("/appointments/", response_model=AppointmentResponse, status_code=status.HTTP_201_CREATED)
async def create_appointment(appointment: AppointmentCreate, db: Session = Depends(get_db), current_user: dict = Depends(get_current_user)):
    logger.info(f"=== CREATE APPOINTMENT DEBUG ===")
    logger.info(f"Current user from token: {current_user}")

    # Validar que el doctor existe
    doctor = db.query(Doctor).filter(Doctor.id == appointment.doctor_id).first()
    if not doctor:
        raise HTTPException(status_code=404, detail=f"Doctor with ID {appointment.doctor_id} not found")

    # Extraer datos del usuario del token
    user_id = int(current_user.get("user_id", 1))
    user_email = current_user.get("email", "testuser@example.com")
    user_name = current_user.get("username", "Test User")

    # Crear la cita en la base de datos CON TODOS LOS CAMPOS REQUERIDOS
    db_appointment = Appointment(
        patient_id=user_id,
        patient_email=user_email,
        patient_name=user_name,
        doctor_id=appointment.doctor_id,
        appointment_date=appointment.appointment_date,
        appointment_time=appointment.appointment_time,
        reason=appointment.reason,
        status="scheduled"
    )

    try:
        db.add(db_appointment)
        db.commit()
        db.refresh(db_appointment)
        logger.info(f"✅ Cita creada exitosamente: ID {db_appointment.id}")
        logger.info(f"   Patient: {user_name} ({user_email})")
        logger.info(f"   Doctor: {doctor.name} (ID: {doctor.id})")
    except Exception as e:
        db.rollback()
        logger.error(f"❌ Error al crear cita en BD: {str(e)}")
        logger.error(f"Error type: {type(e)}")
        import traceback
        logger.error(f"Traceback: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")

    # Publicar evento a RabbitMQ
    try:
        from rabbitmq_utils import publish_appointment_created
        publish_appointment_created({
            "appointment_id": db_appointment.id,
            "patient_id": db_appointment.patient_id,
            "patient_email": db_appointment.patient_email,
            "patient_name": db_appointment.patient_name,
            "doctor_id": db_appointment.doctor_id,
            "appointment_date": db_appointment.appointment_date.isoformat() if hasattr(db_appointment.appointment_date, 'isoformat') else str(db_appointment.appointment_date),
            "appointment_time": db_appointment.appointment_time,
            "reason": db_appointment.reason,
            "status": db_appointment.status,
            "created_at": datetime.utcnow().isoformat()
        })
        logger.info(f"✅ Evento publicado a RabbitMQ para cita ID {db_appointment.id}")
    except Exception as e:
        logger.error(f"⚠️ Error publicando evento RabbitMQ: {str(e)}")
        # No fallamos la creación de cita si RabbitMQ falla

    return db_appointment

@router.put("/appointments/{appointment_id}", response_model=AppointmentResponse)
def update_appointment(appointment_id: int, appointment_update: AppointmentUpdate, db: Session = Depends(get_db), current_user: dict = Depends(get_current_user)):
    db_appointment = db.query(Appointment).filter(Appointment.id == appointment_id).first()
    if db_appointment is None:
        raise HTTPException(status_code=404, detail="Appointment not found")

    # Actualizar campos
    update_data = appointment_update.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_appointment, field, value)

    db.commit()
    db.refresh(db_appointment)
    return db_appointment

@router.delete("/appointments/{appointment_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_appointment(appointment_id: int, db: Session = Depends(get_db), current_user: dict = Depends(get_current_user)):
    appointment = db.query(Appointment).filter(Appointment.id == appointment_id).first()
    if appointment is None:
        raise HTTPException(status_code=404, detail="Appointment not found")

    db.delete(appointment)
    db.commit()
    return None

