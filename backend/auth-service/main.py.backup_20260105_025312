import logging
from fastapi import FastAPI, HTTPException, Header, Form, Depends
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from datetime import timedelta
from sqlalchemy.orm import Session
from sqlalchemy import text

from database import create_tables, get_db, User
from auth_utils import (
    authenticate_user, 
    create_access_token, 
    get_current_user,
    ACCESS_TOKEN_EXPIRE_MINUTES
)

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="HDUCE Auth Service",
    description="Authentication and authorization microservice",
    version="2.0.0"
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

def crear_engine_auth():
    """Solución definitiva - crea engine directamente"""
    from sqlalchemy import create_engine
    from hduce_shared.config import settings
    
    db = settings.database
    password = "postgres"
    connection_string = f"postgresql://{db.postgres_user}:{password}@{db.postgres_host}:{db.postgres_port}/{db.auth_db}"
    logger.info(f"Conectando a PostgreSQL: {db.postgres_host}:{db.postgres_port}/{db.auth_db}")
    return create_engine(connection_string, pool_pre_ping=True)

@app.on_event("startup")
async def startup_event():
    """Inicializar base de datos al iniciar"""
    try:
        engine = crear_engine_auth()
        
        # Verificar conexión
        with engine.connect() as conn:
            conn.execute(text("SELECT 1"))
        logger.info("✅ Conexión a auth_db establecida")
        
        # Crear tablas si no existen
        try:
            create_tables()
            logger.info("✅ Tablas creadas/verificadas")
        except Exception as e:
            logger.warning(f"Las tablas ya existen o error: {e}")
            
    except Exception as e:
        logger.error(f"❌ Database initialization failed: {e}")
        import traceback
        logger.error(traceback.format_exc())

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "auth", "database": "connected"}

@app.get("/")
async def root():
    """Root endpoint"""
    return {
        "service": "auth-service",
        "version": "2.0.0",
        "status": "running",
        "endpoints": ["/login", "/validate-token", "/users", "/users/{id}"]
    }

@app.post("/login")
async def login(
    username: str = Form(...),
    password: str = Form(...),
    db: Session = Depends(get_db)
):
    """Login con base de datos real"""
    logger.info(f"Intento de login para usuario: {username}")
    
    user = authenticate_user(db, username, password)
    
    if not user:
        logger.warning(f"Autenticación fallida para: {username}")
        raise HTTPException(
            status_code=401,
            detail="Credenciales incorrectas o usuario inactivo"
        )
    
    # Actualizar último login
    from datetime import datetime
    user.last_login = datetime.utcnow()
    db.commit()
    
    # Crear token
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username, "role": user.role, "email": user.email},
        expires_delta=access_token_expires
    )
    
    logger.info(f"Login exitoso para: {user.username} (rol: {user.role})")
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "user": user.to_dict(),
        "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60
    }

@app.get("/validate-token")
async def validate_token(
    authorization: str = Header(None),
    db: Session = Depends(get_db)
):
    """Valida un token JWT con base de datos"""
    if not authorization or not authorization.startswith("Bearer "):
        return JSONResponse(
            status_code=401,
            content={"error": "Missing or invalid authorization header"}
        )
    
    token = authorization.split(" ")[1]
    user = get_current_user(token, db)
    
    if not user:
        return JSONResponse(
            status_code=401,
            content={"error": "Invalid token or user not found"}
        )
    
    return {
        "valid": True,
        "user": user.to_dict(),
        "token_info": {
            "issued_for": user.username,
            "role": user.role
        }
    }

@app.get("/users")
async def get_users(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db)
):
    """Obtener lista de usuarios (solo admin)"""
    users = db.query(User).filter(User.is_active == True).offset(skip).limit(limit).all()
    return {"users": [user.to_dict() for user in users], "count": len(users)}

@app.get("/users/{user_id}")
async def get_user(user_id: int, db: Session = Depends(get_db)):
    """Obtener usuario por ID"""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    return user.to_dict()

@app.get("/test-db")
async def test_db(db: Session = Depends(get_db)):
    """Endpoint para probar conexión a DB"""
    count = db.query(User).count()
    return {
        "database": "connected",
        "user_count": count,
        "users_sample": [user.to_dict() for user in db.query(User).limit(3).all()]
    }

@app.post("/auth/login")
async def login_auth(
    username: str = Form(...),
    password: str = Form(...),
    db: Session = Depends(get_db)
):
    """Login endpoint con prefijo /auth/ para compatibilidad"""
    return await login(username, password, db)

@app.get("/auth/validate-token")
async def validate_token_auth(
    authorization: str = Header(None),
    db: Session = Depends(get_db)
):
    """Validate token endpoint con prefijo /auth/ para compatibilidad"""
    return await validate_token(authorization, db)

@app.get("/auth/users")
async def get_users_auth(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db)
):
    """Get users endpoint con prefijo /auth/ para compatibilidad"""
    return await get_users(skip, limit, db)

@app.get("/auth/users/{user_id}")
async def get_user_auth(user_id: int, db: Session = Depends(get_db)):
    """Get user by ID endpoint con prefijo /auth/ para compatibilidad"""
    return await get_user(user_id, db)

@app.get("/auth/test-db")
async def test_db_auth(db: Session = Depends(get_db)):
    """Test DB endpoint con prefijo /auth/ para compatibilidad"""
    return await test_db(db)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
