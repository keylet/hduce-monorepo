"""
RabbitMQ Consumer estandarizado usando shared libraries hduce_shared
Versión CORREGIDA que guarda notificaciones en BD - ESQUEMA FIXED
"""
import json
import logging
import threading
import time
from typing import Dict, Any
from datetime import datetime

# Configuración de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

try:
    from hduce_shared.rabbitmq.consumer import RabbitMQConsumer
    SHARED_LIB_AVAILABLE = True
    logger.info("? Usando RabbitMQConsumer de shared libraries")
except ImportError as e:
    SHARED_LIB_AVAILABLE = False
    logger.error(f"? No se pudo importar shared libraries: {e}")
    # Mantener como fallback
    import pika

def process_appointment_message(message_data: Dict[str, Any]) -> None:
    """
    Procesa mensajes de creación de citas y guarda en BD.
    COMPATIBLE CON EL ESQUEMA REAL DE LA TABLA notifications
    """
    try:
        logger.info(f"?? Mensaje recibido: {json.dumps(message_data, indent=2)}")

        # Extraer datos del mensaje
        appointment_data = message_data.get('data', message_data)

        # Extraer información importante
        appointment_id = (
            appointment_data.get('appointment_id') or
            appointment_data.get('id') or
            message_data.get('appointment_id')
        )

        patient_email = (
            appointment_data.get('patient_email') or
            message_data.get('patient_email') or
            "usuario@ejemplo.com"
        )

        # Para user_id, usamos un valor por defecto (1) si no viene en el mensaje
        # En producción debería venir del token JWT
        patient_id = (
            appointment_data.get('patient_id') or
            message_data.get('patient_id') or
            1  # Valor por defecto para pruebas
        )

        patient_name = (
            appointment_data.get('patient_name') or
            message_data.get('patient_name') or
            "Usuario"
        )

        if appointment_id and patient_email:
            logger.info(f"? Procesando cita #{appointment_id} para {patient_email}")

            # GUARDAR EN BASE DE DATOS CON ESQUEMA CORRECTO
            try:
                # Importar dentro de la función para evitar problemas de importación circular
                from sqlalchemy.orm import Session
                from database import SessionLocal
                from models import Notification
                
                db: Session = SessionLocal()
                
                # Crear notificación con ESQUEMA CORRECTO según models.py
                notification = Notification(
                    user_id=patient_id,  # ? CORREGIDO: user_id en lugar de user_name
                    user_email=patient_email,
                    notification_type="appointment_created",
                    title=f"Nueva cita programada - Doctor #{appointment_data.get('doctor_id', 'N/A')}",
                    message=f"Cita #{appointment_id}: {patient_name} tiene una cita el {appointment_data.get('appointment_date', 'fecha desconocida')} a las {appointment_data.get('appointment_time', 'hora desconocida')}",
                    is_read=False,
                    created_at=datetime.now(),
                    read_at=None  # ? Añadido según esquema
                )
                
                db.add(notification)
                db.commit()
                db.refresh(notification)
                db.close()
                
                logger.info(f"? Notificación guardada en BD: ID={notification.id}, user_id={notification.user_id}, type={notification.notification_type}")
                
            except Exception as db_error:
                logger.error(f"? Error al guardar en BD: {db_error}")
                import traceback
                logger.error(traceback.format_exc())
                # Intentar conectar nuevamente si hay error
                try:
                    db.close()
                except:
                    pass

        return True

    except Exception as e:
        logger.error(f"? Error procesando mensaje: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return False

def start_consumer():
    """Inicia el consumer usando shared libraries"""
    if not SHARED_LIB_AVAILABLE:
        logger.error("? Shared libraries no disponibles. No se puede iniciar consumer.")
        return

    try:
        consumer = RabbitMQConsumer()

        def callback(message_data: Dict[str, Any]):
            """Callback para procesar mensajes"""
            process_appointment_message(message_data)

        # Iniciar en background
        thread = consumer.start_in_background(callback)
        logger.info(f"? Consumer iniciado en thread: {thread.name}")

        return consumer

    except Exception as e:
        logger.error(f"? Error iniciando consumer: {e}")

if __name__ == "__main__":
    logger.info("?? Iniciando RabbitMQ Consumer con shared libraries...")
    consumer = start_consumer()

    if consumer:
        try:
            # Mantener el script corriendo
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            logger.info("?? Deteniendo consumer...")
            if SHARED_LIB_AVAILABLE:
                consumer.close()
