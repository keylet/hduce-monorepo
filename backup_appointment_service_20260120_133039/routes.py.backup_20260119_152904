from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from database import get_db
from models import Appointment, Doctor, Specialty
from schemas import AppointmentCreate, Appointment, Doctor
from auth_client import verify_token
from rabbitmq_utils import publish_to_rabbitmq

appointment_routes = APIRouter()

def get_current_user(token: str):
    """Verificar token JWT"""
    return verify_token(token)

@appointment_routes.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "appointment-service"}

@appointment_routes.get("/doctors")
async def get_doctors(db: Session = Depends(get_db)):
    """Obtener lista de doctores con sus especialidades"""
    try:
        doctors = db.query(Doctor).all()
        
        doctor_responses = []
        for doctor in doctors:
            doctor_responses.append({
                "id": doctor.id,
                "name": doctor.name,
                "email": doctor.email,
                "specialty_id": doctor.specialty_id,
                "specialty": {
                    "id": doctor.specialty.id if doctor.specialty else None,
                    "name": doctor.specialty.name if doctor.specialty else None
                }
            })
        
        return {"doctors": doctor_responses}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving doctors: {str(e)}")

@appointment_routes.post("/")
async def create_appointment(
    appointment: AppointmentCreate,
    current_user: dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Crear una nueva cita"""
    try:
        # Verificar que el doctor exista
        db_doctor = db.query(Doctor).filter(Doctor.id == appointment.doctor_id).first()
        if not db_doctor:
            raise HTTPException(status_code=404, detail="Doctor not found")
        
        # Crear nueva cita
        db_appointment = Appointment(
            patient_id=current_user.get("user_id"),
            patient_email=appointment.patient_email,
            patient_name=appointment.patient_name,
            doctor_id=appointment.doctor_id,
            appointment_date=appointment.appointment_date,
            appointment_time=appointment.appointment_time,
            status="scheduled",
            notes=appointment.notes
        )
        
        db.add(db_appointment)
        db.commit()
        db.refresh(db_appointment)
        
        # Crear evento para RabbitMQ
        appointment_event = {
            "event_type": "appointment_created",
            "appointment_id": db_appointment.id,
            "patient_id": db_appointment.patient_id,
            "patient_email": db_appointment.patient_email,
            "patient_name": db_appointment.patient_name,
            "doctor_id": db_appointment.doctor_id,
            "appointment_date": str(db_appointment.appointment_date),
            "appointment_time": str(db_appointment.appointment_time),
            "status": db_appointment.status,
            "created_at": str(db_appointment.created_at)
        }
        
        # Publicar evento
        publish_to_rabbitmq(appointment_event)
        
        return {
            "message": "Appointment created successfully",
            "appointment": {
                "id": db_appointment.id,
                "patient_id": db_appointment.patient_id,
                "patient_email": db_appointment.patient_email,
                "patient_name": db_appointment.patient_name,
                "doctor_id": db_appointment.doctor_id,
                "appointment_date": str(db_appointment.appointment_date),
                "appointment_time": str(db_appointment.appointment_time),
                "status": db_appointment.status,
                "notes": db_appointment.notes,
                "created_at": str(db_appointment.created_at)
            }
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error creating appointment: {str(e)}")

@appointment_routes.get("/")
async def get_user_appointments(
    current_user: dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Obtener citas del usuario actual"""
    try:
        appointments = db.query(Appointment).filter(
            Appointment.patient_id == current_user.get("user_id")
        ).all()
        
        appointment_responses = []
        for appointment in appointments:
            appointment_responses.append({
                "id": appointment.id,
                "patient_id": appointment.patient_id,
                "patient_email": appointment.patient_email,
                "patient_name": appointment.patient_name,
                "doctor_id": appointment.doctor_id,
                "appointment_date": str(appointment.appointment_date),
                "appointment_time": str(appointment.appointment_time),
                "status": appointment.status,
                "notes": appointment.notes,
                "created_at": str(appointment.created_at)
            })
        
        return {"appointments": appointment_responses}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving appointments: {str(e)}")