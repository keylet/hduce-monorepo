# backend/appointment-service/routes.py - VERSIÓN CORREGIDA
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from database import get_db
import models
from schemas import AppointmentCreate, Appointment, Appointment
from auth_client import validate_token  # ← Importar validate_token correctamente

appointment_routes = APIRouter(prefix="/api/appointments", tags=["appointments"])

# ============================================================================
# DEPENDENCIAS DE AUTENTICACIÓN - CORREGIDO
# ============================================================================

# get_current_user ahora usa validate_token con Depends
def get_current_user(token: str = Depends(validate_token)):
    """Obtener usuario actual desde token JWT"""
    return token  # validate_token ya devuelve el payload del usuario

# ============================================================================
# ENDPOINTS
# ============================================================================

@appointment_routes.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "appointment-service"}

@appointment_routes.get("/doctors")
async def get_doctors(db: Session = Depends(get_db)):
    """Obtener lista de doctores con sus especialidades"""
    try:
        doctors = db.query(models.Doctor).all()

        doctor_responses = []
        for models.Doctor in doctors:
            doctor_responses.append({
                "id": models.Doctor.id,
                "name": models.Doctor.name,
                "email": models.Doctor.email,
                "specialty_id": models.Doctor.specialty_id,
                "specialty_name": models.Doctor.models.Specialty.name if models.Doctor.models.Specialty else None
            })

        return doctor_responses

    except Exception as e:
        print(f"❌ Error en get_doctors: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error al obtener doctores"
        )

@appointment_routes.post("/")
async def create_appointment(
    appointment: AppointmentCreate,
    current_user: dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Crear una nueva cita"""
    try:
        # Verificar que el models.Doctor exista
        db_doctor = db.query(models.Doctor).filter(models.Doctor.id == appointment.doctor_id).first()
        if not db_doctor:
            raise HTTPException(status_code=404, detail="models.Doctor not found")

        # Crear nueva cita
        db_appointment = models.Appointment(
            patient_id=current_user.get("user_id"),
            patient_email=appointment.patient_email,
            patient_name=appointment.patient_name,
            doctor_id=appointment.doctor_id,
            appointment_date=appointment.appointment_date,
            appointment_time=appointment.appointment_time,
            notes=appointment.notes,
            status="scheduled"
        )

        db.add(db_appointment)
        db.commit()
        db.refresh(db_appointment)

        # Publicar evento a RabbitMQ
        try:
            from rabbitmq_utils_simple import publish_appointment_created
            message = {
                "event_type": "appointment_created",
                "appointment_id": db_appointment.id,
                "patient_email": db_appointment.patient_email,
                "patient_name": db_appointment.patient_name,
                "doctor_id": db_appointment.doctor_id,
                "appointment_date": str(db_appointment.appointment_date),
                "appointment_time": str(db_appointment.appointment_time),
                "created_at": str(db_appointment.created_at)
            }
            publish_to_rabbitmq(message)
            print(f"✅ Evento publicado a RabbitMQ para cita {db_appointment.id}")
        except Exception as e:
            print(f"⚠️ Error al publicar a RabbitMQ: {e}")
            # No fallar la creación de la cita si RabbitMQ falla

        # Devolver respuesta
        return {
            "id": db_appointment.id,
            "patient_id": db_appointment.patient_id,
            "patient_email": db_appointment.patient_email,
            "patient_name": db_appointment.patient_name,
            "doctor_id": db_appointment.doctor_id,
            "appointment_date": db_appointment.appointment_date,
            "appointment_time": db_appointment.appointment_time,
            "status": db_appointment.status,
            "notes": db_appointment.notes,
            "created_at": db_appointment.created_at
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"❌ Error en create_appointment: {e}")
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error al crear la cita"
        )

@appointment_routes.get("/")
async def get_appointments(
    current_user: dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Obtener citas del usuario actual"""
    try:
        user_id = current_user.get("user_id")
        appointments = db.query(Appointment).filter(
            Appointment.patient_id == user_id
        ).all()

        return appointments

    except Exception as e:
        print(f"❌ Error en get_appointments: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error al obtener citas"
        )

router = appointment_routes





