from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime
import logging

from database import SessionLocal, engine
from models import Appointment, Doctor, Specialty
from schemas import AppointmentCreate, AppointmentUpdate, AppointmentResponse
from auth_client import verify_token
from rabbitmq_utils_simple import publish_appointment_created as publish_appointment_event

router = APIRouter(prefix="/api", tags=["appointments"])

# Configurar logging
logger = logging.getLogger(__name__)

# Dependency para obtener sesión de BD
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Dependency para verificar token
def get_current_user(token: str = Depends(verify_token)):
    return token

@router.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "appointment", "timestamp": datetime.now().isoformat()}

@router.get("/appointments/", response_model=List[AppointmentResponse])
def read_appointments(
    skip: int = 0, 
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Obtener todas las citas (solo admin en producción)"""
    appointments = db.query(Appointment).offset(skip).limit(limit).all()
    return appointments

@router.get("/appointments/{appointment_id}", response_model=AppointmentResponse)
def read_appointment(
    appointment_id: int,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Obtener una cita específica"""
    appointment = db.query(Appointment).filter(Appointment.id == appointment_id).first()
    if appointment is None:
        raise HTTPException(status_code=404, detail="Appointment not found")
    return appointment

@router.post("/appointments/", response_model=AppointmentResponse, status_code=status.HTTP_201_CREATED)
def create_appointment(
    appointment: AppointmentCreate,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Crear una nueva cita"""
    logger.info(f"Creando cita para usuario: {current_user}")
    
    # Usar patient_id del token si no se proporciona
    if appointment.patient_id is None:
        appointment.patient_id = current_user.get("user_id")
        logger.info(f"Usando patient_id del token: {appointment.patient_id}")
    
    # Verificar que el doctor existe
    doctor = db.query(Doctor).filter(Doctor.id == appointment.doctor_id).first()
    if doctor is None:
        raise HTTPException(status_code=400, detail="Doctor not found")
    
    # Crear la cita
    db_appointment = Appointment(**appointment.dict())
    db.add(db_appointment)
    db.commit()
    db.refresh(db_appointment)
    
    logger.info(f"? Cita creada exitosamente: ID {db_appointment.id}")
    
    # Publicar evento a RabbitMQ
    try:
        publish_appointment_event(
            event_type="APPOINTMENT_CREATED",
            appointment_id=db_appointment.id,
            patient_id=db_appointment.patient_id,
            patient_email=current_user.get("email"),
            patient_name=current_user.get("name"),
            doctor_id=db_appointment.doctor_id,
            appointment_date=db_appointment.appointment_date.isoformat() if db_appointment.appointment_date else None,
            reason=db_appointment.reason
        )
        logger.info(f"? Evento publicado a RabbitMQ para cita {db_appointment.id}")
    except Exception as e:
        logger.error(f"? Error publicando evento a RabbitMQ: {e}")
        # No lanzamos excepción para no fallar la creación de la cita
    
    return db_appointment

@router.put("/appointments/{appointment_id}", response_model=AppointmentResponse)
def update_appointment(
    appointment_id: int,
    appointment_update: AppointmentUpdate,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Actualizar una cita existente"""
    db_appointment = db.query(Appointment).filter(Appointment.id == appointment_id).first()
    if db_appointment is None:
        raise HTTPException(status_code=404, detail="Appointment not found")
    
    # Actualizar campos
    update_data = appointment_update.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_appointment, field, value)
    
    db.commit()
    db.refresh(db_appointment)
    return db_appointment

@router.delete("/appointments/{appointment_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_appointment(
    appointment_id: int,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Eliminar una cita"""
    appointment = db.query(Appointment).filter(Appointment.id == appointment_id).first()
    if appointment is None:
        raise HTTPException(status_code=404, detail="Appointment not found")
    
    db.delete(appointment)
    db.commit()
    return None
