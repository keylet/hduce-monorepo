from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
import os
# from hduce_shared.config import settings

from database import get_db
import models
import schemas

# ========== RABBITMQ SIMPLE ==========
import pika
import json
from datetime import datetime

def publish_to_rabbitmq(appointment_data):
    """Publicar evento a RabbitMQ"""
    try:
        # Obtener configuración desde variables de entorno
        rabbitmq_host = os.getenv("RABBITMQ_HOST", "rabbitmq")
        rabbitmq_port = int(os.getenv("RABBITMQ_PORT", 5672))

        credentials = pika.PlainCredentials(
            os.getenv("RABBITMQ_USER", "guest"),
            os.getenv("RABBITMQ_PASSWORD", "guest")
        )

        # CREAR LA CONEXIÓN (esto es lo que faltaba)
        connection = pika.BlockingConnection(
            pika.ConnectionParameters(
                host=rabbitmq_host,
                port=rabbitmq_port,
                credentials=credentials,
                heartbeat=600,
                blocked_connection_timeout=300
            )
        )

        channel = connection.channel()

        # Exchange y queue
        channel.exchange_declare(
            exchange="appointments",
            exchange_type="direct",
            durable=True
        )

        channel.queue_declare(
            queue="appointment_notifications",
            durable=True
        )

        channel.queue_bind(
            exchange="appointments",
            queue="appointment_notifications",
            routing_key="appointment.created"
        )

        # Mensaje
        message = {
            "event_type": "APPOINTMENT_CREATED",
            "timestamp": datetime.now().isoformat(),
            "data": appointment_data
        }

        channel.basic_publish(
            exchange="appointments",
            routing_key="appointment.created",
            body=json.dumps(message, ensure_ascii=False),
            properties=pika.BasicProperties(
                delivery_mode=2,
                content_type="application/json"
            )
        )

        print("SUCCESS: Evento publicado a RabbitMQ: APPOINTMENT_CREATED")
        connection.close()
        return True

    except Exception as e:
        print(f"ERROR: Error publicando a RabbitMQ: {e}")
        return False
router = APIRouter()

# ========== RUTAS DE DOCTORES ==========
@router.get("/doctors", response_model=List[schemas.Doctor])
def get_doctors(db: Session = Depends(get_db)):
    """Obtener todos los doctores"""
    doctors = db.query(models.Doctor).all()
    # Si los doctores no tienen nombre, asignar uno
    for doctor in doctors:
        if not doctor.name:
            doctor.name = f"Doctor {doctor.user_id}"
    return doctors

@router.get("/doctors/{doctor_id}", response_model=schemas.Doctor)
def get_doctor(doctor_id: int, db: Session = Depends(get_db)):
    """Obtener un doctor por ID"""
    doctor = db.query(models.Doctor).filter(models.Doctor.id == doctor_id).first()
    if not doctor:
        raise HTTPException(status_code=404, detail="Doctor not found")
    if not doctor.name:
        doctor.name = f"Doctor {doctor.user_id}"
    return doctor

# ========== RUTAS DE ESPECIALIDADES ==========
@router.get("/specialties", response_model=List[schemas.Specialty])
def get_specialties(db: Session = Depends(get_db)):
    """Obtener todas las especialidades"""
    return db.query(models.Specialty).all()

@router.get("/specialties/{specialty_id}", response_model=schemas.Specialty)
def get_specialty(specialty_id: int, db: Session = Depends(get_db)):
    """Obtener una especialidad por ID"""
    specialty = db.query(models.Specialty).filter(models.Specialty.id == specialty_id).first()
    if not specialty:
        raise HTTPException(status_code=404, detail="Specialty not found")
    return specialty

# ========== RUTAS DE CITAS ==========
@router.get("", response_model=List[schemas.Appointment])
def get_appointments(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """Obtener todas las citas"""
    return db.query(models.Appointment).offset(skip).limit(limit).all()

@router.post("", response_model=schemas.Appointment)
def create_appointment(appointment: schemas.AppointmentCreate, db: Session = Depends(get_db)):
    """Crear una nueva cita"""

    # Verificar que el doctor existe
    doctor = db.query(models.Doctor).filter(models.Doctor.id == appointment.doctor_id).first()
    if not doctor:
        raise HTTPException(status_code=404, detail="Doctor not found")

    # Crear la cita
    db_appointment = models.Appointment(
        patient_id=appointment.patient_id,
        doctor_id=appointment.doctor_id,
        appointment_date=appointment.appointment_date,
        reason=appointment.reason,
        notes=appointment.notes,
        status="scheduled"
    )

    db.add(db_appointment)
    db.commit()
    db.refresh(db_appointment)
    
    # ========== PUBLICAR A RABBITMQ ==========
    try:
        appointment_event = {
            "id": db_appointment.id,
            "patient_id": db_appointment.patient_id,
            "doctor_id": db_appointment.doctor_id,
            "appointment_date": db_appointment.appointment_date.isoformat() if db_appointment.appointment_date else None,
            "reason": db_appointment.reason,
            "status": db_appointment.status
        }
        publish_to_rabbitmq(appointment_event)
    except Exception as e:
        print(f"WARNING: Error en RabbitMQ (cita creada igual): {e}")
    # =========================================

    return db_appointment

# ========== RUTA PARA UNA CITA ESPEC?FICA ==========
@router.get("/appointment/{app_id}", response_model=schemas.Appointment)
def get_appointment_by_id(app_id: int, db: Session = Depends(get_db)):
    """Obtener una cita por ID"""
    appointment = db.query(models.Appointment).filter(models.Appointment.id == app_id).first()
    if not appointment:
        raise HTTPException(status_code=404, detail="Appointment not found")
    return appointment

# ========== HEALTH CHECKS ==========
@router.get("/health")
def health_check():
    return {"status": "healthy", "service": "appointment"}

@router.get("/db-check")
def db_check(db: Session = Depends(get_db)):
    """Verificar conexion a base de datos"""
    try:
        doctor_count = db.query(models.Doctor).count()
        specialty_count = db.query(models.Specialty).count()
        appointment_count = db.query(models.Appointment).count()

        return {
            "status": "healthy",
            "doctor_count": doctor_count,
            "specialty_count": specialty_count,
            "appointment_count": appointment_count
        }
    except Exception as e:
        return {"status": "error", "message": str(e)}








