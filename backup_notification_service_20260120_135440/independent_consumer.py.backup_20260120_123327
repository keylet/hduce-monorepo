import json
import logging
import time
import pika
from sqlalchemy.orm import Session
from database import SessionLocal
from models import Notification
import traceback

# Configuración de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configuración de RabbitMQ
RABBITMQ_HOST = 'rabbitmq'
RABBITMQ_PORT = 5672
RABBITMQ_USER = 'guest'
RABBITMQ_PASS = 'guest'
EXCHANGE_NAME = 'appointments'
QUEUE_NAME = 'appointment_notifications'
ROUTING_KEY = 'notification.created'

def connect_to_rabbitmq():
    """Conecta a RabbitMQ con reintentos"""
    max_retries = 5
    retry_delay = 5
    
    for attempt in range(max_retries):
        try:
            credentials = pika.PlainCredentials(RABBITMQ_USER, RABBITMQ_PASS)
            parameters = pika.ConnectionParameters(
                host=RABBITMQ_HOST,
                port=RABBITMQ_PORT,
                credentials=credentials,
                heartbeat=600,
                blocked_connection_timeout=300
            )
            connection = pika.BlockingConnection(parameters)
            channel = connection.channel()
            
            # Declarar exchange y queue
            channel.exchange_declare(exchange=EXCHANGE_NAME, exchange_type='direct', durable=True)
            channel.queue_declare(queue=QUEUE_NAME, durable=True)
            channel.queue_bind(
                exchange=EXCHANGE_NAME,
                queue=QUEUE_NAME,
                routing_key=ROUTING_KEY
            )
            
            logger.info(f"✅ Conectado a RabbitMQ. Exchange: {EXCHANGE_NAME}, Queue: {QUEUE_NAME}")
            return connection, channel
            
        except Exception as e:
            logger.error(f"❌ Error conectando a RabbitMQ (intento {attempt + 1}/{max_retries}): {e}")
            if attempt < max_retries - 1:
                logger.info(f"Reintentando en {retry_delay} segundos...")
                time.sleep(retry_delay)
            else:
                raise

def save_notification_to_db(user_id: int, user_email: str, message: str, notification_type: str = "appointment_created"):
    """Guarda una notificación en la base de datos"""
    db: Session = SessionLocal()
    try:
        notification = Notification(
            user_id=user_id,
            user_email=user_email,
            message=message,
            notification_type=notification_type,
            is_read=False
        )
        db.add(notification)
        db.commit()
        db.refresh(notification)
        logger.info(f"✅ Notificación guardada en BD: ID={notification.id}, Email={user_email}, Mensaje='{message}'")
        return notification
    except Exception as e:
        db.rollback()
        logger.error(f"❌ Error guardando notificación en BD: {e}")
        logger.error(traceback.format_exc())
        raise
    finally:
        db.close()

def process_message(channel, method, properties, body):
    """Procesa un mensaje de RabbitMQ"""
    try:
        # Decodificar el mensaje
        message_str = body.decode('utf-8')
        message_data = json.loads(message_str)
        
        logger.info(f"📩 Mensaje recibido: {json.dumps(message_data, indent=2)}")
        
        # Extraer datos del mensaje
        event_type = message_data.get("event_type", "").upper()
        data = message_data.get("data", {})
        
        logger.info(f"🔍 Procesando evento: {event_type}")
        
        if event_type == "APPOINTMENT_CREATED" or "APPOINTMENT_CREATED" in str(message_data):
            # Formato 1: event_type en raíz
            if "APPOINTMENT_CREATED" in event_type:
                event_data = data
            else:
                # Formato 2: event_type anidado en data
                event_data = message_data
            
            # Buscar patient_id de diferentes formas
            patient_id = None
            patient_email = None
            patient_name = None
            doctor_id = None
            appointment_date = None
            
            # Buscar en diferentes niveles
            if "patient_id" in event_data:
                patient_id = event_data.get("patient_id")
            elif "data" in event_data and "patient_id" in event_data["data"]:
                patient_id = event_data["data"].get("patient_id")
            
            if "patient_email" in event_data:
                patient_email = event_data.get("patient_email")
            elif "data" in event_data and "patient_email" in event_data["data"]:
                patient_email = event_data["data"].get("patient_email")
            
            if "patient_name" in event_data:
                patient_name = event_data.get("patient_name")
            elif "data" in event_data and "patient_name" in event_data["data"]:
                patient_name = event_data["data"].get("patient_name")
            
            if "doctor_id" in event_data:
                doctor_id = event_data.get("doctor_id")
            elif "data" in event_data and "doctor_id" in event_data["data"]:
                doctor_id = event_data["data"].get("doctor_id")
            
            if "appointment_date" in event_data:
                appointment_date = event_data.get("appointment_date")
            elif "data" in event_data and "appointment_date" in event_data["data"]:
                appointment_date = event_data["data"].get("appointment_date")
            
            # Si no hay patient_id, usar ID 1 como fallback (testuser)
            if not patient_id:
                patient_id = 1
                logger.warning(f"⚠️ No se encontró patient_id, usando ID=1 (testuser)")
            
            # Si no hay patient_email, construir uno
            if not patient_email:
                patient_email = f"patient_{patient_id}@example.com"
                logger.warning(f"⚠️ No se encontró patient_email, usando: {patient_email}")
            
            # Si no hay patient_name, usar genérico
            if not patient_name:
                patient_name = f"Paciente {patient_id}"
            
            # Crear mensaje de notificación
            if doctor_id and appointment_date:
                message = f"Nueva cita programada con Doctor ID: {doctor_id} para {appointment_date}. Paciente: {patient_name}"
            else:
                message = f"Nueva cita médica creada. Paciente: {patient_name}"
            
            logger.info(f"📝 Creando notificación para: Patient ID={patient_id}, Email={patient_email}")
            
            # Guardar en BD
            save_notification_to_db(
                user_id=patient_id,
                user_email=patient_email,
                message=message,
                notification_type="appointment_created"
            )
            
        elif "CANCELLED" in event_type:
            # Procesar cancelación de cita
            patient_id = data.get("patient_id", 1)
            patient_email = data.get("patient_email", f"patient_{patient_id}@example.com")
            appointment_id = data.get("appointment_id", "N/A")
            
            message = f"Cita médica cancelada (ID: {appointment_id})"
            
            save_notification_to_db(
                user_id=patient_id,
                user_email=patient_email,
                message=message,
                notification_type="appointment_cancelled"
            )
        
        else:
            logger.warning(f"⚠️ Evento desconocido: {event_type}. Guardando notificación genérica.")
            
            # Guardar notificación genérica con datos del mensaje
            save_notification_to_db(
                user_id=1,  # testuser como fallback
                user_email="system@example.com",
                message=f"Evento recibido: {event_type}. Datos: {json.dumps(data)[:100]}...",
                notification_type="system_event"
            )
        
        # Acknowledge del mensaje
        channel.basic_ack(delivery_tag=method.delivery_tag)
        logger.info(f"✅ Mensaje procesado y acknowledged: {method.delivery_tag}")
        
    except json.JSONDecodeError as e:
        logger.error(f"❌ Error decodificando JSON: {e}")
        logger.error(f"Body recibido: {body}")
        channel.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
    except Exception as e:
        logger.error(f"❌ Error procesando mensaje: {e}")
        logger.error(traceback.format_exc())
        channel.basic_nack(delivery_tag=method.delivery_tag, requeue=True)

def start_consumer():
    """Inicia el consumer de RabbitMQ"""
    try:
        # Conectar a RabbitMQ
        connection, channel = connect_to_rabbitmq()
        
        # Configurar QoS
        channel.basic_qos(prefetch_count=1)
        
        # Configurar consumer
        channel.basic_consume(
            queue=QUEUE_NAME,
            on_message_callback=process_message,
            auto_ack=False
        )
        
        logger.info("🚀 Consumer de notificaciones iniciado. Esperando mensajes...")
        logger.info(f"📊 Estado: Exchange={EXCHANGE_NAME}, Queue={QUEUE_NAME}, Routing Key={ROUTING_KEY}")
        
        # Iniciar consumo
        channel.start_consuming()
        
    except KeyboardInterrupt:
        logger.info("👋 Consumer detenido por usuario")
        if 'connection' in locals() and connection.is_open:
            connection.close()
    except Exception as e:
        logger.error(f"❌ Error en consumer: {e}")
        logger.error(traceback.format_exc())
        if 'connection' in locals() and connection.is_open:
            connection.close()

if __name__ == "__main__":
    logger.info("🔄 Iniciando consumer de notificaciones...")
    start_consumer()

